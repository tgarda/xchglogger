<?php declare(strict_types=1);

/*
 * This file is a sample debug logger based on Monolog.
 *
 * (c) Tom Garda <tgarda@hotmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace xchg\Logger;

use Monolog\Formatter\FormatterInterface as FormatterInterface;  //this namespace has been autoloaded by Composer
use Monolog\DateTimeImmutable;

// https://github.com/Seldaek/monolog/blob/master/src/Monolog/Formatter/NormalizerFormatter.php
// https://github.com/Seldaek/monolog/blob/master/src/Monolog/Formatter/FormatterInterface.php

//require_once __DIR__ . '/../vendor/monolog/monolog/src/Monolog/Formatter/FormatterInterface.php';

//require_once 'C:\xampp\htdocs3\src\vendor\monolog\monolog\src\Monolog\Formatter\FormatterInterface.php';

/**
 * Outputs nicely formatted, easy to read, multi-line, verbose log entries for debugging purposes
 *
 * @author Tom Garda <tgarda@hotmail.com>
 */
 
class XchgMonologFormatterDebug implements FormatterInterface 
{

	const DEFAULT_SEPARATORLINE = ">>>>>>>>>>>>>>>>";

    protected $separatorLine;

    public function __construct(string $separatorLine = null)
    {
        $this->separatorLine = null === $separatorLine ? static::DEFAULT_SEPARATORLINE : $separatorLine;

    }

    /**
     * {@inheritdoc}
     */
    public function format(array $record)
    {
        return $this->formatForDebug($record);
    }
    /**
     * {@inheritdoc}
     */
    public function formatBatch(array $records)
    {
        foreach ($records as $key => $record) {
            $records[$key] = $this->format($record);
        }
        return $records;
    }
	
	protected function formatForDebug($data) 
	{
	
		$output = "";
		$ctxtitle = array_key_exists('ctxtitle', $data['context']) ? $data['context']['ctxtitle'] : 'notitle';
		$clientip = array_key_exists('extra', $data) && array_key_exists('ip', $data['extra']) ? ' CLIENT IP: ' . $data['extra']['ip'] . ' ' : '';
		
		$output .=  (string) $data['datetime']->format("Y-m-d\TH:i:sP") . ' ' . $data['datetime']->getTimezone()->getName() .
					' logger: ' . $data['channel'] . ' loglevel: ' . $data['level_name'] . "(" .$data['level'] . ')' .
					$clientip .
					PHP_EOL ;
		
		$output .=  "$this->separatorLine START $ctxtitle $this->separatorLine" . PHP_EOL ;
		
		// the Monolog logging record has three sections:
		// $data['message']: generated by regular logging calls, such as $this->logger->debug("testing debug");
		//   - $data['message'] cannot be an array
		// $data['context']: generated by adding contect in logging calls, such as $this->logger->addInfo("user new", array('username' => 'Seldaek', 'age' => 19));
		// $data['extra']: generated by Monolog processors, such as $logger->pushProcessor(function ($record) { ... })
		
		$output .= $this->formatBySimpleType($data['message']) . PHP_EOL;
		
		foreach($data['context'] as $contextkey => $contextvalue) {

			if (strlen($contextkey)>10 && substr($contextkey,0,11) == 'ctxsubtitle') {
				$output .= "==========> $contextvalue" . PHP_EOL;
			} else if (strlen($contextkey)>10 && substr($contextkey,0,11) == 'ctxsubvalue') {
				//$output .= "-- $contextkey: $contextvalue" . PHP_EOL;
				$output .= $this->formatByType($contextvalue, $contextkey);
			} else if /*($contextkey !== 'ctxtitle' ) */ (!in_array($contextkey, ['ctxtitle', 'noextra', 'filterip', 'filteruser', 'filterurl'])) {
				$output .= "$contextkey: $contextvalue" . PHP_EOL;
			}

		}
		
		if (!(array_key_exists('noextra', $data['context']) && $data['context']['noextra'])==1) {
			$output .= "==========> extra fields" . PHP_EOL;
			foreach($data['extra'] as $extrakey => $extravalue) {
			
				if (!in_array($extrakey, array('ip'))) {
					$output .= "-- $extrakey: $extravalue" . PHP_EOL;
				}
			}					
		} 
		
		$output .=  "$this->separatorLine END $ctxtitle   $this->separatorLine" . PHP_EOL . PHP_EOL ;	
		return $output;
		
	}
	
    protected function formatByType($data, $keystring) {
		switch (gettype($data)) {			
			case 'string':
			case 'integer':
			case 'double':
			case 'boolean':
				return $this->formatBySimpleType($data)  . PHP_EOL;
				break;
			case 'NULL':
				return 'NULL' . PHP_EOL;
				break;
			case 'array':
			case 'object':
				$returnstr = "";
				foreach($data as $key => $value) {
					switch(gettype($value)) {
						case 'string':
						case 'integer':
						case 'double':
						case 'boolean':		
							$returnstr .= "$key: " . $this->formatBySimpleType($value)  . PHP_EOL;
							break;
						case 'NULL':
							$returnstr .= 'NULL' . PHP_EOL;
							break;
						case 'array':
						case 'object':
							if ((count($value) == 1) && gettype($value) == 'array') {
								$returnstr .= "-- $key: " . $this->formatBySimpleType(reset($value)) . PHP_EOL ;
							} else {
								$returnstr .= "-- $key: " . PHP_EOL ;
								foreach($value as $subkey => $subvalue) {
									$returnstr .= "---- $subkey: " . $this->formatBySimpleType($subvalue)  . PHP_EOL;
								}
							}
							break;
						default:
							$returnstr .= "-- data type " . gettype($value) . " not supported for debug logging3." . PHP_EOL;
					}
				}
				return $returnstr;
				break;
			default:
				return "-- data type " . gettype($data) . " not supported for debug logging1." . PHP_EOL;		
		}
	}
	
	protected function formatBySimpleType($data) {
		switch (gettype($data)) {
			case 'string':
				return filter_var($data, FILTER_SANITIZE_STRING);
				break;
			case 'integer':
			case 'double':
			case 'boolean':
				return "$data";
				break;
			default:
				return "-- data type " . gettype($data) . " is not a simple type for debug logging2.";				
		}
	}
	

}